# JIT-компилятор
## Аннотация
Заключительный проект на курсах [Дединского Ильи Рудольфовича](https://github.com/ded32), который аккумулировал в себе многие проекты, сделанные за этот учебный год.

## Введение
В этом проекте был создан JIT-компилятор [для моего языка программирования](https://github.com/Waloid24/Language). Целью было транслировать байт-код, который выдавал написанный мною [виртуальный процессор](https://github.com/Waloid24/Processor), в набор машинных инструкций, считываемых реальным процессором. Мы ожидали некоторый прирост производительности в выполнении программы, в конце концов мы его и получили :) Результаты измерений расположены внизу.

## Запуск программы
Чтобы запустить проект на свой машине, клонируйте себе репозиторий:
```
git clone git@github.com:Waloid24/JIT.git
```
Затем скомпилируйте проект с помощью Makefile:
```
make compile
```
После этого запустите программу:
```
make run ./tests/[executable_file_name]
```
Примеры готовых к передачи в качестве параметра файлов расположены [здесь](https://github.com/Waloid24/JIT/tree/main/tests). Вы можете написать на [моём языке](https://github.com/Waloid24/Language) программу, исполнить её, созданный файл с расширением `.bin` из папки `bin` перенести в папку `tests` проекта 'JIT'. Далее запустить 'JIT' с помощью команды выше, написав вместо `[executable_file_name]` имя нужного бинарного файла.

## Как это работает?
### Промежуточное представление
Поступивший в качестве аргумента файл считывается в буфер, который затем обрабатывается:
```c++
    createIRArray   (&compilerInfo);

    fillIRArray     (&compilerInfo);

    setIp (&compilerInfo);

    fillJmpsCalls (&compilerInfo);
```

На выходе получается массив структур, т.е. некоторое промежуточное представление (Intermediate representation, сокращённо - IR) поступившего байт-кода. Вот пример графического дампа:

![IR_dump](./imgs/IR.png)

Кроме того мы оптимизируем полученный массив, чтобы избавиться в будущем от лишних команд.

### Оптимизация
За это отвечает функция:
```c++
optimizeIR (&compilerInfo);
```
Целью оптимизации является уменьшение количества инструкций в итоговом машинном коде и, как следствие, меньший размер буфера с машинным кодом. 

#### Арифметические оптимизации

```asm
push [num1]
push [num2]
sub
```
легко преобразуются в 
```asm
push [num1] - [num2]
```
где `[num]` - число. Операции умножения, деления и сложения преобразуются аналогично.

#### Оптимизации количества команд
Операции типа
```asm
push [num]
pop [reg]
```
преобразуются в 
```asm
mov [reg], [num]
```
где  '[reg]' - регистр общего назначения, а '[num]' - число.

### Перевод в машинные инструкции

Поскольку в моём языке программирования было два стэка, в одном из которых хранились только адреса возврата, а в другом всё остальное, постольку здесь я повторил этот трюк. Использовать одну область памяти в силу заложенных в мой язык принципов невозможно. Для хранения указателя на выделенный под адреса возврата буфер используется регистр `r14`. 

Регистр `r15` отведён под указатель на буфер, который имитирует оперативную память. Там хранятся локальные и глобальные переменные. 

Посмотрим более детально на перевод команд. Я приведу здесь только небольшую их часть, остальное можно найти [здесь](https://github.com/Waloid24/JIT/blob/main/src/translateCommand.cpp).

#### Push/Pop
Некоторые операции не имеют себе прямых аналогов, поэтому приходится реализовывать такие инструкции через набор команд x86-64.

|  Push...  |  ...Pop    |
|-----------|------------|
|Native     |x86-64      |
|push 5     | mov rax, 5 <br/> push rax|
|pop [rax+6]|mov r12, r15 <br/> add r15, rax <br/> pop [r15+6] <br/> mov r15, 12 |

#### In/out
Из-за громоздкости функций приведу пример лишь одной из них:

|        |       in           |
|--------|--------------------|
|Native  | x86-64             |
|in      | sub rsp, 8 <br/> mov rdi, rsp <br/> pusha <br/> mov r12, rsp <br/> and rsp,byte -0x10 <br/> call myScanf <br/> mov rsp, r12 <br/> popa|

где myScanf - функция-обёртка:

```c++
static void myScanf (int * num)
{
    printf ("Enter an integer number: ");
    scanf ("%d", num);
    *num *= 1000;
}
```
Аналогично для функции `out`

#### Математические операции

Поскольку нужно соблюдать повышенную точность вычислений, а компилятор работает только с целыми числами, постольку было принято внутри хранить целые числа, умноженные на тысячу, а во всех операциях учитывать это. Так, например, при умножении двух чисел, мы сначала извлекаем их из стэка, делим каждое из них на тысячу, перемножаем, полученный результат умножаем на тысячу и помещаем его в стэк. В случае же операции сложения или вычитания, таких действий выполнять не нужно.

Пример операции сложения:
|        |    add   |
|--------|----------|
|Native  |  x86-64  |
|add rax, rbx | pop rax <br/> pop rdx <br/> add rdx, rax <br/> push rdx |

Пример операции умножения:
|           |   mul     |
|-----------|-----------|
|Native     |   x86-64  |
|mul rax    | pop rax <br/> cvtsi2sd xmm1, rax <br/> pop rax <br/> cvtsi2sd xmm0, rax <br/> mov rax, 1000 <br/> cvtsi2sd xmm2, rax <br/> divpd xmm0, xmm2 <br/> divpd xmm1, xmm2 <br/> mulpd xmm0, xmm1 <br/> mulpd xmm0, xmm2 <br/> cvtsd2si rax, xmm0 <br/> push rax |

#### Прыжки

Безусловный jmp переносится на машинные команды без изменений. Под relAddr мы понимаем относительный адрес цели. Важно, что он отсчитывается от начала следующей за jmp инструкцией. 

|           |    jmp    |
|-----------|-----------|
|Native     | x86-64    |
|jmp .label | jmp relAddr |

Условный же jmp переносится с некоторыми изменениями. Сначала мы берём из стэка два числа, сравниваем их и в зависимости от результата прыгаем или нет.
|           |   je      |
|-----------|-----------|
| Native    |  x86-64   |
|je .label  |  pop rax <br/> pop rdx <br/> cmp rdx, rax <br/> je .label |

### Ускорение
Сравним скорость выполнения байт-кода и машинного кода на примере выполнения программы `factorial.txt`, причём компилировать проект с байт-кодом будем под флагом оптимизации `-O2`. Уберём команду `in`, а вместо неё положим в переменную `a` целочисленную константу:
```
factorial aurora num umbra
salve
    inceptus aurora num == 0 umbra
    salve
        reditum 1 ora
    vale
    a assignare num mul factorial aurora num subtrahere 1 umbra ora
    reditum a ora
vale

main aurora umbra
salve
    a assignare 6 ora
    inceptus aurora a >= 0 umbra
    salve
        b assignare factorial aurora a umbra ora
        print aurora b umbra ora
    vale
    cruciatus
    salve
        print aurora 0 umbra ora
    vale
    reditum 0 ora
vale
```
В таблице приведены результаты выполнения программы `1000000` раз. 

|    Исполнитель      | Время выполнения, с | Коэффициент ускорения |
|---------------------|---------------------|-----------------------|
|Виртуальный процессор|     69.737          |           1           |
|   Процессор x86-64  |     1.595           |          43.7         |

Уберём теперь функцию печати `print` и заново измерим. Получим:

|    Исполнитель      | Время выполнения, с | Коэффициент ускорения |
|---------------------|---------------------|-----------------------|
|Виртуальный процессор|     63.880          |           1           |
|   Процессор x86-64  |     0.089           |          717.7        |

Видно, что вызов стандартной функции языка C сильно замедлил программу. 

## Заключение
Из результатов видно, что мы превзошли флаг `-O2` в 43.7 раз в версии, где присутствует функция `print`, и в 717.7 раза в версии, где она отсутствует. Хороший результат :)

## Планы на будущее
На носу сессия, так что реализовать все задумки сейчас не представляется возможным. 
Во-первых, в будущем хочется написать свой elf-файл, полезно знать, что представляет из себя elf-файл.
Во-вторых, я бы поработал над парсингом байт-кода: хочется получать промежуточное представление за меньшее число проходов. Некоторые наработки готовы, но сразу реализовать их не получилось. 
Во-третьих, стоит найти более сильные оптимизации промежуточного представления. 
В-четвёртых, соединить проекты `Scielang` с 'JIT'.

